## 数据库设计三范式

1、数据库设计三范式：
      设计数据库表的时候所依据的规范，共三个范式

2、第一范式：
      要求有主键，并且每个字段原子性不可在分。

3、第二范式：
      要求所有非主键完全依赖主键，不能产生部分依赖

4、第三范式：
      所有非主键字段和主键字段之间不能产生传递依赖

5、几个比较经典的设计：

      一对一：
              第一种方案：分两张表存储，共享主键，

              第二种方案：分两张表存储，外键唯一

      一对多：
              分两张表存储，在多的一方添加外键，这个外键字段引用一方的一方中的主键字段

      多对多：
              分三张表存储，在学生信息表中存储学生信息，在课程表中存储课程信息，在学生选课表中存储选课信息。

6、实际开发中是怎样的？
      数据库设计尽量遵循三范式
      但是还是根据业务场景进行取舍
      有时候可能会拿冗余数据换速度
      最终的目的是要满足客户的需求


## 视图

- 视图是一种根据查询定义的数据库对象，用于想看到或局部数据
- 视图有时候也成为“虚拟表”
- 视图可以被用来从常规表或者其他视图中查询数据
- 相对于从基表中直接获取数据，视图有如下好处：
  - 访问数据变得简单
  - 可被用来对不同用户显示不同的内容

视图作用：

    - 提高检索效率
    - 隐藏表的实现细节


## 索引

1、什么是索引？

    - 索引对应的单词为：index
    - 索引相当于一本字典的目录，索引的作用是提高程序的检索效率
2、主键自动添加索引，所以能够通过主键查询尽量通过主键查询

3、索引和表相同，都是一个对象，表是存储在银盘文件中，那么索引是表的一部分，索引也是存储在硬盘文件中的

4、在MySQL数据库管理系统中，对表中记录进行检索时，通常包括几种检索方式：

    - 第一种方式：全文扫描(效率较低)
    - 第二种方式：通过索引进行检索(效率较高)

5、什么情况下适合给表中的某个字段添加索引呢？
    - 该字段数据量庞大
    - 该字段很少的DML操作(DMl操作很多的话，索引也是需要不断维护的，效率反而降低)
    - 该字段经常出现在where条件中

6、创建索引
    create index dept_index on dept(dname)
    create unique index dept_dname_index on dept(dname)   //添加unique表示给dname字段添加唯一索引

## 存储引擎

存储引擎的使用
    - 数据库中各表均被指定的存储引擎来处理
    - 服务器可用的引擎依赖于以下因素：
        - MySQL版本
        - 服务器在开发时如何配置
        - 启动选项

    - 可以使用show engines\G查看数据库中有哪些存储引擎
    - 也可以查看指定的查看 show variables like 'engine%';

常用的存储引擎

MyISAM存储引擎：
    - MyISAM存储引擎是MySQL最常用的引擎
    - 它管理的表具有以下特征：
        - 使用三个文件表示每个表
            - 格式文件*.frm --存储表结构的定义
            - 数据文件*.MYD --存储表行的内容
            - 索引文件*.MyI --存储表上的索引
        - 灵活的AUTO_INTREMENT字段处理
        - 可被转换为压缩、只读表来节约空间

InnoDE存储引擎
    - InnoDB存储引擎是MySQL的缺省疫情
    - 它管理的表现具体有下列特征：
        - 每个InnoDB表在数据库目录中以*.frm格式文件表示的
        - 提供一组用来记录事务性活动的日志和文件
        - 提供全ACID兼容
        - 用commit(提交)、savepoint和rollback(回滚)支持事务处理
        - 在MySQL服务器奔溃后提供自动回复
        - 多版本(MVCC)和行级锁定
        - 支持外键及引用的完整性，包括级联删除和更新

MEMORY存储引擎
    - 使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定，
    - MEMORY存储引擎管理的表具有以下特征：
        - 在数据目录中噢乖，每个表以*.frm格式文件表示
        - 表数据及索引存储在内存中
        - 表级锁机制
    - MEMORY存储引擎以前被称为HEAP引擎

选择合适的存储引擎
    - 当创建表时，因根据表的应用场景选择合适的存储引擎
    - MyISAM表适合于大量的数据读而少量数据更新的的混合操作
    - 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为读取数据和更新数据的混合操作提供了良好的并发机制
    - 可以用MEMORY存储引擎存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成数据

## 事务

1、什么是事务？
      - 事务对应的英文单词：Transaction
      - 一个最小的不可在分的工作单元
      - 通常一个事务对应一个完整的业务  【例如：银行的转账，该业务就是一个最小工作单元】
      - 而一个完整的业务需要批量的DML语句共同完成联合完成
 事务可以保证多个操作原子性，要么全成功，要么全失败，对于数据库来说事务保证批量的DML要么全成功，要么全失败

 2、事物具备以下四个特征ACID
    - 原子性 (Atomicity)
        - 整个事务中的操作，必须作为ieyige单元全部完成或全部取消

    - 一致性 (Consistency)
        - 在事务开始之前和结束之后，数据库保持一致的状态

    - 隔离性 (Isolation)
        - 一个事务不会影响到其他事务的运行

    - 持久性 (Durability)
        在事务完成之后，该事务对数据库所作的更改将持久的保存在磁盘上，并不会被回滚

3、事务中存在一些概念
    - 事务 (Transaction) ：一批操作
    - 开启事务 (Start Transaction)
    - 回滚事务 (rollback)
    - 提交事务 (用commit)

4、重点
    在事务进行过程中，为结束知其那，DML语句是不会更改底层数据库文件中的数据。
    只是将历史记录操作一下，在内存中完成记录。只有在事务结束的时候，而且是成功的情况下才会修改底层硬盘文件中的数据。

5、事务四个特性之一：隔离性(Isolation)

    - 事务A呵呵事务B之间具有一定的隔离性

    - 隔离性有隔离级别
        - 读未提交 (read uncommitted)
        - 读已提交 (read committed)
        - 可重复读 (repeatable read)
        - 串行化 (serializable)

    - 读未提交 (read uncommitted)
        - 事务A和事务B，事务A未提交的数据，事务B可以读到，
        - 这里读到的数据可以叫做“脏数据”或者“脏读”
        - 这种隔离级别是最低的，一般都是在理论中存在的，

    - 读已提交 (read committed)
        - 事务A和事务B，事务A提交的数据，事务B才能读取到
        - 这种隔离级别高于读未提交，会避免出现脏读
        - 只有对方事务提交之后，我当前事务才能够读取到
        - 这中隔离级别会导致“不可重复读取”
        - ORACLE数据库默认的是“读已提交”

    - 可重复读 (repeatabls read) 
        - 事务A和事务B，事务A提交之后的数据，事务B读取不到
        - 事务B是可重复读取的数据。
        - 这种隔离级别高于读已提交
        - 换句话说：对方提交的数据　我还是读取不到
        - 这种级别可以避免“不可重复读”，达到可重复读
        - MySQL默认的是“可重复读”
        - 可以避免“可重复读”，但会导致“幻读”

     - 串行化 (serializable)
        - 事务A和事务B，事务A在操作数据库的时候，事务B只能排队等待
        - 这种事务隔离级别一般很少用，吞吐量太低，用户体验差。
        - 这种隔离级别可以避免“幻读”，每一次读取的都是数据库表中真实的记录
        - 事务A和事务B不在并发。